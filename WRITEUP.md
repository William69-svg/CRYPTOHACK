# WRITE-UP CRYPTOHACK: 20 BÀI ĐẦU TIÊN RSA CHALLENGE  
# STARTER
## 1. Modular exponentiation & 2. Public keys

**SỬ DỤNG HAI CÁCH ĐỂ TÍNH HÀM MODULE LUỸ THỪA**
Cách 1:
Ý tưởng: tạo hàm tính luỹ thừa theo vòng lặp và lấy module theo số m.
```C++
#include <iostream>
#include <math.h>
#include <stdio.h>
using namespace std;
int MOD(int a, int b, int m){    //THIET LAP HAM TINH MODULE
    long long s = 1;              
    for (int i = 1; i <=b; i++){ //TAO VONG LAP THEO DO LON CUA LUY THUA
        s*= a;                   //NHAN SO A VAO BIEN S  
        s%= m;                   //DONG THOI CHIA DU CHO SO m DE TRANH TRAN MAN HINH
    }
    return s; //TRA VE GIA TRI S SAU KHI DUOC GAN HAM MODULE
}
```



Cách 2 (theo em tìm hiểu trên mạng)
**Ý tưởng: dùng phương pháp tính luỹ thừa nhanh(trình bày theo cách hiểu của em)**
VÍ DỤ: $a^{10} = a^{5} \cdot a^{5} \lor a^{5} = a^{2} \cdot a^{2} \cdot a$

Khi b chẵn: cơ số tăng 2 và luỹ thừa: $a^{b} = (a^{2})^{\frac{b}{2}}$

Khi b lẻ: luỹ thừa giẳm 1 đơn vị: $a^{b} = (a^{2})^{\frac{b - 1}{2}}$

CÓ THỂ THẤY SẼ GIÚP GIẢM SỐ LẦN THỰC HIỆN PHÉP TOÁN CÒN MỘT NỬA MỖI LẦN THỰC HIỆN VÒNG LẶP
```C++
long long MOD3(int a, int b, int m){    //THIET LAP HAM 
     long long s = 1;                    //KHOI TAO GIA TRI S 
     while (b){                          //DUNG VONG LAP KHI LUY THUA != 0
         if ( b%2==1 ){                  //NEU NHU B LA SO LE   
         s *= a;                         //TA NHAN S VOI A 
         s %= m;                         //THUC HIEN PHEP TOAN MOD DE TOI UU HOA BAI TOAN
     }
         b /= 2;                         //THUC HIEN VIEC GIAM LUY THUA 
         a *= a;                         //BINH PHUONG GIA TRI CUA A THEO NHU MO TA   
         a %= m;                         //VA THUC HIEN PHEP TOAN MOD VOI A SAU KHI BINH PHUONG
     }
         return s;                       //TRA LAI GIA TRI S
}

//PHẦN MAIN EM THỰC HIỆN CẢ YÊU CẦU CỦA BÀI 1 VÀ 2
int main (){
    int a, m;
    int p = 17, q = 23; 
    long long e = 65537; 
    m = p*q;
    cout << "so can nhap la: ";
    cin >> a;
    long long s = MOD(a, e, m);    //THUC HIEN THAM TRI DUA TREN DU LIEU CUA HAM
    cout << "so can tim la: " << s << endl;    //IN KQ KET THUC BAI TOAN
    return 0;
}
ANS: 19906 & 301
```
## 3. Euler's Totient

Giải bài toán tìm giá trị phi Euler
```c++
#include <iostream>
using namespace std;

int main() {
    long long p = 857504083339712752489993810777LL;
    long long q = 1029224947942998075080348647219LL;
    
    long long phiEuler = (p - 1) * (q - 1);

    cout << phiEuler << endl;

    return 0;
}
``` 

Cách hiểu sai: đếm các số nguyên tố nhỏ hơn hoặc bằng N, thiếu điều kiện nếu số đó không nguyên tố với N thì không nhận 
```c++
long long EulerTot(long long n){         //Thiet lap ham phan tich thanh thua so nguyen to
     long long Euler = n;
     for (long long i = 2; i <= sqrt(n); i++){
         if (n%i==0){                     //Dieu kien ban dau     
             while (n%i==0){
             n /= i;                      //Khi chia het cho tung so nguyen to thi tiep tuc thuc hien vong lap  
             }
             Euler -= Euler/i;            //Thuc hien loai bo cac boi so cua cac so nguyen to tim duoc
         }
     }
     if (n>1){                            //Sau khi thuc hien cac phep chia nhung n van lon hon 1 thi chua loc ra het toan bo cac thua so nguyen to
         Euler -= Euler/n;                //Tuong tu ben tren vong lap
     }
         return Euler;
 }
 int main(){
     long long p = 857504083339712752489993810777LL, q = 1029224947942998075080348647219LL;
     long long n = p*q;
     cout << EulerTot(n);  
     return 0;
 }
```
$ANS: \phi(N) = 882564595536224140639625987657529300394956519977044270821168$
## 4. Private keys

**Hàm mở rộng của thuật toán Euclid để tìm d**

GIẢI THÍCH CÁCH HOẠT ĐỘNG CỦA HÀM EUCLID MỞ RỘNG (theo cách hiểu của em):

Dựa vào phương trình bên trên ta có: $a \cdot x + b \cdot y = GCD(a, b)$ khi ƯCLN của nó bằng 1 thì sẽ có được thuật toán RSA (với $d \cdot e \equiv 1 \pmod{b}$)

Để có thể giải phương trình này thì chúng ta cần biết và hiểu cách hoạt động của một phương trình nghiệm nguyên $a \cdot x + b \cdot y = c$

Quay lại bài toán, với a, b là e và $\phi(N)$ và x, y là lần lượt là các biến số cần tìm 

Ta có: $a = b \cdot y + x$ (a mod b) khi phép toán a mod b được thực hiện thì x, y cũng thay đổi

Phép thử: $ a = 30, b = 12, (x0, y0), (x1, y1), 30 $\cdot$ x + 12 $\cdot$ y = GCD(30, 12) $

Lần chia thứ 1: $30 = 12 \cdot 2 + 6(R)$

$a \cdot x0 + b \cdot y0 = 6$

Dễ thấy: (x0, y0) = (1; -2) và thoả mãn định lý euler với GCD(a, b) = 6

Lần chia thứ 2: $6 = 6 \cdot 1 + 0(R)$ 

Tương tư: (x1, y1) = (2; -5) không thoả mãn định lý 

Với cách hoạt động như trên ta có thể áp dụng để tìm d trong RSA khi GCD = 1

```c++
#include <iostream>
#include <stdio.h>
#include <math.h>

using namespace std;
a*x + b*y = GCD(a, b)

long long EuclidMoRong(long long a, long long b, long long &x, long long &y) {
    if (a == 0) {     // Xét trường hợp đầu tiên khi a, x = 0 và y bằng 1 thì trả lại giá trị b là GCD (a, b) 
        x = 0;
        y = 1;
        return b;
    }
    long long x1, y1; // Các giá trị trung gian
    long long gcd = EuclidMoRong(b % a, a, x1, y1); //truyen cac tham chieu va tham tri
        return gcd;
}

```
Trong khi thực hiện phép toán thì x và y lần lượt thay đổi

Như trong ví dụ trên: tại lần thứ n thực hiện bài toán: 

Ta có: $GCD(a, b) = a \cdot x + b \cdot y$

Khi đó ở bước tiếp theo: GCD(b, a mod b) = $b \cdot x1$ + (a  mod  b) $\cdot y1$ hay $b \cdot x1 + (a - (\frac{a}{b}) \cdot b) \cdot y1$

$\rightarrow a \cdot y1 + b \cdot (x1 - (\frac{a}{b}) \cdot y1)$

Ở những bước tiếp theo khi nào phép toán chưa thực hiện xong thì bước hoán đổi vẫn còn...

Vậy nên sẽ thực hiện phép đệ quy, các biến x và y sẽ luân chuyển liên tục như sau:  

$x = y1 - (\frac{b}{a}) \cdot x1$; 

y = x1;


**Hàm để tìm d, là nghịch đảo modular của e trong modulo phi**
```c++
long long ModuleNghichdao(long long e, long long phi) {
    long long x, y;
    long long g = EuclidMoRong(e, phi, x, y);           // Gọi hàm Euclid vừa xây dựng
    if (g != 1) {                                       // Khi GCD != 1 thì phép toán tính d không được thực hiện
        cout << "Nghịch đảo modular không tồn tại" << endl;
        return -1; // Không có nghịch đảo nếu gcd khác 1
    } else {
        // Đảm bảo x dương
        long long d = (x % phi + phi) % phi;            // Sau khi gọi hàm và đưa ra điều kiện như trên, ta xét tới điều kiện của d (d>0)
        return d;                                       // Trả về giá trị d sau khi gọi hàm
    }
}

int main() {
    long long e;     // Giá trị của e
    long long phi;  // Giá trị của phi(n)
        cin >> e;
        cin >> phi;  
    long long d = ModuleNghichdao(e, phi); // Bước tính toán Inverse modular
    if (d != -1) {                         // Điều kiện để d thoả mãn chìa khoá và để cho thuật toán RSA hoạt động
        cout << "Giá trị của d là: " << d << endl;
    }

    return 0;
}
```
$ANS: d = 121832886702415731577073962957377780195510499965398469843281$
**Sau khi nhận ra công dụng của Python quá mạnh mẽ, em đã sử dụng Python**
## 5. RSA Decryption

```python
d = 121832886702415731577073962957377780195510499965398469843281
N = 882564595536224140639625987659416029426239230804614613279163
e = 65537
c = 77578995801157823671636298847186723593814843845525223303932
print(pow(c,d,N))
```
$ANS = 13371337$

## 6. RSA Signature 

```python
import hashlib
data = "crypto{Immut4ble_m3ssag1ng}"
hash_object = hashlib.sha256(data.encode())
hash_hex = hash_object.hexdigest()
hash_byte = bytes.fromhex(hash_hex)
hash_long = int.from_bytes(hash_byte, byteorder = 'big')

N = 15216583654836731327639981224133918855895948374072384050848479908982286890731769486609085918857664046075375253168955058743185664390273058074450390236774324903305663479046566232967297765731625328029814055635316002591227570271271445226094919864475407884459980489638001092788574811554149774028950310695112688723853763743238753349782508121985338746755237819373178699343135091783992299561827389745132880022259873387524273298850340648779897909381979714026837172003953221052431217940632552930880000919436507245150726543040714721553361063311954285289857582079880295199632757829525723874753306371990452491305564061051059885803
d = 11175901210643014262548222473449533091378848269490518850474399681690547281665059317155831692300453197335735728459259392366823302405685389586883670043744683993709123180805154631088513521456979317628012721881537154107239389466063136007337120599915456659758559300673444689263854921332185562706707573660658164991098457874495054854491474065039621922972671588299315846306069845169959451250821044417886630346229021305410340100401530146135418806544340908355106582089082980533651095594192031411679866134256418292249592135441145384466261279428795408721990564658703903787956958168449841491667690491585550160457893350536334242689
H = hash_long

Hm = pow(H, d, N)
print(Hm)
```
$Ans = 13480738404590090803339831649238454376183189744970683129909766078877706583282422686710545217275797376709672358894231550335007974983458408620258478729775647818876610072903021235573923300070103666940534047644900475773318682585772698155617451477448441198150710420818995347235921111812068656782998168064960965451719491072569057636701190429760047193261886092862024118487826452766513533860734724124228305158914225250488399673645732882077575252662461860972889771112594906884441454355959482925283992539925713424132009768721389828848907099772040836383856524605008942907083490383109757406940540866978237471686296661685839083475$

# Primes part 1
## 7. Factoring
```Python
from sympy import factorint
n = 510143758735509025530880200653196460532653147
factor = factorint(n)
factor_max = max(factor.keys())
factor_min = min(factor.keys())
# De in so be hon thi 
print(f"Thua so nguyen to nho hon la: {factor_min}")
```
$Ans = 19704762736204164635843$

## 8. Inferius Prime 
```python
from Crypto.Util.number import inverse, bytes_to_long, long_to_bytes

p, q = 752708788837165590355094155871, 986369682585281993933185289261
n, phi = p * q, (p - 1) * (q - 1)
e = 3
d = inverse(e, phi)
ct = 39207274348578481322317340648475596807303160111338236677373 
pt = (long_to_bytes(pow(ct, d, n))
print (pt)
```
Ans: crypto{N33d_b1g_pR1m35}

## 9. Monoprime
```python
from Crypto.Util.number import long_to_bytes, inverse

n = 171731371218065444125482536302245915415603318380280392385291836472299752747934607246477508507827284075763910264995326010251268493630501989810855418416643352631102434317900028697993224868629935657273062472544675693365930943308086634291936846505861203914449338007760990051788980485462592823446469606824421932591
e = 65537
ct = 161367550346730604451454756189028938964941280347662098798775466019463375610700074840105776873791605070092554650190486030367121011578171525759600774739890458414593857709994072516290998135846956596662071379067305011746842247628316996977338024343628757374524136260758515864509435302781735938531030576289086798942

d = inverse(e, n-1)
m = pow(ct, d, n)
print(long_to_bytes(m))
```
Ans: crypto{0n3_pr1m3_41n7_pr1m3_l0l}

## 10. Square Eyes
```python
from sympy import factorint
from Crypto.Util.number import getPrime, inverse, bytes_to_long, long_to_bytes, GCD
n = 535860808044009550029177135708168016201451343147313565371014459027743491739422885443084705720731409713775527993719682583669164873806842043288439828071789970694759080842162253955259590552283047728782812946845160334801782088068154453021936721710269050985805054692096738777321796153384024897615594493453068138341203673749514094546000253631902991617197847584519694152122765406982133526594928685232381934742152195861380221224370858128736975959176861651044370378539093990198336298572944512738570839396588590096813217791191895941380464803377602779240663133834952329316862399581950590588006371221334128215409197603236942597674756728212232134056562716399155080108881105952768189193728827484667349378091100068224404684701674782399200373192433062767622841264055426035349769018117299620554803902490432339600566432246795818167460916180647394169157647245603555692735630862148715428791242764799469896924753470539857080767170052783918273180304835318388177089674231640910337743789750979216202573226794240332797892868276309400253925932223895530714169648116569013581643192341931800785254715083294526325980247219218364118877864892068185905587410977152737936310734712276956663192182487672474651103240004173381041237906849437490609652395748868434296753449
e = 65537
ct = 222502885974182429500948389840563415291534726891354573907329512556439632810921927905220486727807436668035929302442754225952786602492250448020341217733646472982286222338860566076161977786095675944552232391481278782019346283900959677167026636830252067048759720251671811058647569724495547940966885025629807079171218371644528053562232396674283745310132242492367274184667845174514466834132589971388067076980563188513333661165819462428837210575342101036356974189393390097403614434491507672459254969638032776897417674577487775755539964915035731988499983726435005007850876000232292458554577437739427313453671492956668188219600633325930981748162455965093222648173134777571527681591366164711307355510889316052064146089646772869610726671696699221157985834325663661400034831442431209123478778078255846830522226390964119818784903330200488705212765569163495571851459355520398928214206285080883954881888668509262455490889283862560453598662919522224935145694435885396500780651530829377030371611921181207362217397805303962112100190783763061909945889717878397740711340114311597934724670601992737526668932871436226135393872881664511222789565256059138002651403875484920711316522536260604255269532161594824301047729082877262812899724246757871448545439896


factor = factorint(n)
prime_factor = list(factor.keys())

prime_max = max(factor.keys())
prime_min = min(factor.keys())
phi = (prime_max - 1) * (prime_min - 1)
p = prime_factor[0]
phi = (p - 1)*p
```
phi = (p - 1)*p có công thức này là vì n chính là một số nguyên tố, chứ không được cấu thành từ p và q hay nhiều số nguyên tố khác
```python
d = inverse (e, phi)
pt = pow (ct, d, n) 
decrypted = long_to_bytes(pt) 
print(decrypted)
decrypted_string = decrypted.decode('utf-8', errors='ignore')
decrypted_string = decrypted.decode('ascii', errors='ignore')
decrypted_string = decrypted.decode('iso-8859-1', errors='ignore')
decrypted_string = decrypted.decode('latin-1', errors='ignore')



print (f"flag la: {decrypted_string}")
```
Ans: crypto{squar3_r00t_i5_f4st3r_th4n_f4ct0r1ng!}

## 11. Manyprimes
**Bài này có khá nhiều thừa số nguyên tố, nên đưa nó ra một tập hợp số và dùng công thức tính $\phi(N)$**
```python
from Crypto.Util.number import inverse, long_to_bytes

N = 580642391898843192929563856870897799650883152718761762932292482252152591279871421569162037190419036435041797739880389529593674485555792234900969402019055601781662044515999210032698275981631376651117318677368742867687180140048715627160641771118040372573575479330830092989800730105573700557717146251860588802509310534792310748898504394966263819959963273509119791037525504422606634640173277598774814099540555569257179715908642917355365791447508751401889724095964924513196281345665480688029639999472649549163147599540142367575413885729653166517595719991872223011969856259344396899748662101941230745601719730556631637
e = 65537
ct = 320721490534624434149993723527322977960556510750628354856260732098109692581338409999983376131354918370047625150454728718467998870322344980985635149656977787964380651868131740312053755501594999166365821315043312308622388016666802478485476059625888033017198083472976011719998333985531756978678758897472845358167730221506573817798467100023754709109274265835201757369829744113233607359526441007577850111228850004361838028842815813724076511058179239339760639518034583306154826603816927757236549096339501503316601078891287408682099750164720032975016814187899399273719181407940397071512493967454225665490162619270814464

factors = (9282105380008121879, 9303850685953812323, 9389357739583927789, 10336650220878499841, 10638241655447339831, 11282698189561966721, 11328768673634243077, 11403460639036243901, 11473665579512371723, 11492065299277279799, 11530534813954192171, 11665347949879312361, 12132158321859677597, 12834461276877415051, 12955403765595949597, 12973972336777979701, 13099895578757581201, 13572286589428162097, 14100640260554622013, 14178869592193599187, 14278240802299816541, 14523070016044624039, 14963354250199553339, 15364597561881860737, 15669758663523555763, 15824122791679574573, 15998365463074268941, 16656402470578844539, 16898740504023346457, 17138336856793050757, 17174065872156629921, 17281246625998849649)

phi = 1
for prime in factors:
    phi *= (prime - 1)

d = inverse(e, phi)

pt = pow(ct, d, N)
print(long_to_bytes(pt))
```
Ans: crypto{700_m4ny_5m4ll_f4c70r5}

# Public Exponent
## 12. Salty
**Bài này là một trường họp đặc biệt khi cho e = 1 và ct < n**
```python
from Crypto.Util.number import getPrime, inverse, bytes_to_long, long_to_bytes, GCD
n = 110581795715958566206600392161360212579669637391437097703685154237017351570464767725324182051199901920318211290404777259728923614917211291562555864753005179326101890427669819834642007924406862482343614488768256951616086287044725034412802176312273081322195866046098595306261781788276570920467840172004530873767                                                                  
e = 1 
ct = 44981230718212183604274785925793145442655465025264554046028251311164494127485

pt = ct
decrypted = long_to_bytes(pt)
decrypted_string = decrypted.decode('utf-8', errors = 'ignore')
print(decrypted_string)
```
Ans: crypto{saltstack_fell_for_this!}

## 13. Modulus Inutilis
**Sử dụng phương pháp tấn công Hastad's Broadcast Attack**

**Vì e = 3 và c < n nên phép module không ảnh hưởng đến m hay $m^{3}$**
```python
n = 17258212916191948536348548470938004244269544560039009244721959293554822498047075403658429865201816363311805874117705688359853941515579440852166618074161313773416434156467811969628473425365608002907061241714688204565170146117869742910273064909154666642642308154422770994836108669814632309362483307560217924183202838588431342622551598499747369771295105890359290073146330677383341121242366368309126850094371525078749496850520075015636716490087482193603562501577348571256210991732071282478547626856068209192987351212490642903450263288650415552403935705444809043563866466823492258216747445926536608548665086042098252335883
e = 3
ct = 243251053617903760309941844835411292373350655973075480264001352919865180151222189820473358411037759381328642957324889519192337152355302808400638052620580409813222660643570085177957


from Crypto.Util.number import getPrime, inverse, bytes_to_long, long_to_bytes
# với n = 3 và ciphertext quá nhỏ so với n
# với low public expotentiation thì ta dùng phương pháp Hastad
# ct = pt^e

pt = pow(ct, 1/e)
decrypted = long_to_bytes(pt)
print(decrypted)
```
Ans: crypto{N33d_m04R_p4dd1ng}

## 14. Everything is Big
**Bài này sử dụng Weiner Attack do e là một số tương đối lớn**
```python
import owiener
from Crypto.Util.number import long_to_bytes

# Đổi từ hex sang decimal

N = 23314261774711635287199613322625299631998299531668574856054445891367514103118788671741746880773471358355043843424178957765687991051382738221889741391209910265414558275853987805928032540504091325882973089325788388764059748141908558032906355962434381133814683631259503022678117195972953901341152390082323332013081727028250772610795079682074032005674396787209080870144904438012362544373403906582078249640767748443695976768936365312724837274503878342188073955100351982119862045062809973110618490322000848950789796929040191128376295484446101182115221654618310291664010793027421046736723687597493681537019384653365187810893
e = 19530226410043970810725557003435543135763530881424210248055253789146116962119210614869432985570865118752985919383689598525891574886387777910656552352995376444381466131799115118821582068507614159079491660471660498703856657100219432169415694357051026653501587627161359216917068611699460388404704994020658035113867704564864520447628130219204036115956229378374533904177298511420691232986523029437427813718184752726121102827577815324799236044788791890210324092921530775467785171769947364981150722141109135873933436026419757925700203197178661307541794973688656649796675223608169318604829628635422095313615753614708538760163
c = 8028121224227573051828850229994462997334629895742133475980102822209497303556216779775942543561944932524150303356432654518807957178569209410177254952777287867269725600174363472416920972657180694221524823357993311941711660626697551627760577426753521788921114199242994421027253907973286593309748059366733997153548521855813763130272553602724942731498310511847885977497728649159363241087645689831666350800348400155464399327635456578067757425624251823026377947503169196936361131843633441040763103641837689196421514573226485717472879713606424296498797414793405914833918934223936424519120394289446392279412227764722289357940
d = owiener.attack(e, N) # Nhận thấy e ~ N nên ta dùng phương pháp Weiner
m = pow (c, d, N)
print(long_to_bytes(m))
```
Ans: crypto{s0m3th1ng5_c4n_b3_t00_b1g}

## 15. Crossed Wires
**Đối với bài này khi đọc Source code có thể nhận ra Cipher text đã được mũ e mod N nên ta có thể Decrypt thì ta Factor N tìm d với khoá công khai của từng người và phi, và tìm ngược lại m thì ta mũ d mod N** 
```python
from Crypto.Util.number import long_to_bytes, inverse
N = 21711308225346315542706844618441565741046498277716979943478360598053144971379956916575370343448988601905854572029635846626259487297950305231661109855854947494209135205589258643517961521594924368498672064293208230802441077390193682958095111922082677813175804775628884377724377647428385841831277059274172982280545237765559969228707506857561215268491024097063920337721783673060530181637161577401589126558556182546896783307370517275046522704047385786111489447064794210010802761708615907245523492585896286374996088089317826162798278528296206977900274431829829206103227171839270887476436899494428371323874689055690729986771
d = 2734411677251148030723138005716109733838866545375527602018255159319631026653190783670493107936401603981429171880504360560494771017246468702902647370954220312452541342858747590576273775107870450853533717116684326976263006435733382045807971890762018747729574021057430331778033982359184838159747331236538501849965329264774927607570410347019418407451937875684373454982306923178403161216817237890962651214718831954215200637651103907209347900857824722653217179548148145687181377220544864521808230122730967452981435355334932104265488075777638608041325256776275200067541533022527964743478554948792578057708522350812154888097
e = 65537
e1, e2, e3, e4, e5 = 106979, 108533, 69557, 97117, 103231
# factor N
p = 134460556242811604004061671529264401215233974442536870999694816691450423689575549530215841622090861571494882591368883283016107051686642467260643894947947473532769025695530343815260424314855023688439603651834585971233941772580950216838838690315383700689885536546289584980534945897919914730948196240662991266027
q = 161469718942256895682124261315253003309512855995894840701317251772156087404025170146631429756064534716206164807382734456438092732743677793224010769460318383691408352089793973150914149255603969984103815563896440419666191368964699279209687091969164697704779792586727943470780308857107052647197945528236341228473
M = 20304610279578186738172766224224793119885071262464464448863461184092225736054747976985179673905441502689126216282897704508745403799054734121583968853999791604281615154100736259131453424385364324630229671185343778172807262640709301838274824603101692485662726226902121105591137437331463201881264245562214012160875177167442010952439360623396658974413900469093836794752270399520074596329058725874834082188697377597949405779039139194196065364426213208345461407030771089787529200057105746584493554722790592530472869581310117300343461207750821737840042745530876391793484035024644475535353227851321505537398888106855012746117
phi = (p - 1)*(q - 1)
d1 = inverse(e1, phi)
d2 = inverse(e2, phi)
d3 = inverse(e3, phi)
d4 = inverse(e4, phi)
d5 = inverse(e5, phi)
dn = d1*d2*d3*d4*d5
m = long_to_bytes(pow(M, dn, N))
print(m)
```
Ans: crypto{3ncrypt_y0ur_s3cr3t_w1th_y0ur_fr1end5_publ1c_k3y}

## 16. Everything is Big 2
**Lấy ý tưởng từ bài trước**
```python 
from Crypto.Util.number import long_to_bytes
import owiener
N = int('0xb12746657c720a434861e9a4828b3c89a6b8d4a1bd921054e48d47124dbcc9cfcdcc39261c5e93817c167db818081613f57729e0039875c72a5ae1f0bc5ef7c933880c2ad528adbc9b1430003a491e460917b34c4590977df47772fab1ee0ab251f94065ab3004893fe1b2958008848b0124f22c4e75f60ed3889fb62e5ef4dcc247a3d6e23072641e62566cd96ee8114b227b8f498f9a578fc6f687d07acdbb523b6029c5bbeecd5efaf4c4d35304e5e6b5b95db0e89299529eb953f52ca3247d4cd03a15939e7d638b168fd00a1cb5b0cc5c2cc98175c1ad0b959c2ab2f17f917c0ccee8c3fe589b4cb441e817f75e575fc96a4fe7bfea897f57692b050d2b', 16)
e = int('0x9d0637faa46281b533e83cc37e1cf5626bd33f712cc1948622f10ec26f766fb37b9cd6c7a6e4b2c03bce0dd70d5a3a28b6b0c941d8792bc6a870568790ebcd30f40277af59e0fd3141e272c48f8e33592965997c7d93006c27bf3a2b8fb71831dfa939c0ba2c7569dd1b660efc6c8966e674fbe6e051811d92a802c789d895f356ceec9722d5a7b617d21b8aa42dd6a45de721953939a5a81b8dffc9490acd4f60b0c0475883ff7e2ab50b39b2deeedaefefffc52ae2e03f72756d9b4f7b6bd85b1a6764b31312bc375a2298b78b0263d492205d2a5aa7a227abaf41ab4ea8ce0e75728a5177fe90ace36fdc5dba53317bbf90e60a6f2311bb333bf55ba3245f', 16)
c = int('0xa3bce6e2e677d7855a1a7819eb1879779d1e1eefa21a1a6e205c8b46fdc020a2487fdd07dbae99274204fadda2ba69af73627bdddcb2c403118f507bca03cb0bad7a8cd03f70defc31fa904d71230aab98a10e155bf207da1b1cac1503f48cab3758024cc6e62afe99767e9e4c151b75f60d8f7989c152fdf4ff4b95ceed9a7065f38c68dee4dd0da503650d3246d463f504b36e1d6fafabb35d2390ecf0419b2bb67c4c647fb38511b34eb494d9289c872203fa70f4084d2fa2367a63a8881b74cc38730ad7584328de6a7d92e4ca18098a15119baee91237cea24975bdfc19bdbce7c1559899a88125935584cd37c8dd31f3f2b4517eefae84e7e588344fa5', 16)
# factor N
# Tương tự bài đầu tiên e ~ N
d = owiener.attack(e, N)
m = long_to_bytes(pow(c, d, N))
print(m)
```
Ans: crypto{bon3h5_4tt4ck_i5_sr0ng3r_th4n_w13n3r5}

## 17. Endless Emails
**Ý TƯỞNG CỦA BÀI**:

NHẬN THẤY SỖ MŨ CÔNG KHAI THẤP VÀ NHIỀU CẶP KHOÁ CÔNG KHAI KHÁC NHAU

DỰA VÀO PHƯƠNG PHÁP HASTAD BROADCAST VÀ CHINESE REMAINDER THEOREM (CRT)

MÔ TẢ CÁC BƯỚC CỤ THỂ:

CÁC BƯƠC THỰC HIỆN BÀI TOÁN ĐỊNH LÝ DƯ TRUNG QUỐC

Bước đầu tiên: ta lấy số dư $c_i$ của các phép toán M $\pmod{n_i}$ (VỚI $c_i$ = $M^{3} \pmod{n_i}$) 

Tiếp theo: tìm Modulus $N_i$ = $\frac{N}{n_i}$ (với N là tích của i phần tử $n_i$)

Từ đó: với $N_i$ tương ứng với $M_i$ là nghịch đảo Modulus của $N_i \pmod{n_i}$

Và ta có thể tính $M = (\sum_{i = 1}^{e} r_i * N_i * M_i \pmod{N}$

VỚI MỖI LẦN THỰC HIỆN TA LÀM VỚI BỘ 3 SỐ ĐỂ THOẢ ĐIỀU KIỆN BAN ĐẦU

Khi đó $m < n_i$ nên $m^{3} < N$ tìm m là thông điệp gốc ta chỉ cần lấy $\sqrt[3]{M}$

```python
from itertools import combinations      # Dùng để tạo ra các bộ 3 số
from Crypto.Util.number import *
from gmpy2 import iroot
# Dựa vào cách giải thích trên ta xây dựng hàm CRT

def CRT(remainder, modulus):
    assert len(remainder) == len(modulus)
    N = 1               # Khởi tạo giá trị để tính tích của n_i 
    for i in modulus:
        N*=i            # Tích của các giá trị modulus 
    Ni = []
    for i in range(len(modulus)):        # Lấy ra các chỉ số phần tử trong mảng modulus
        Ni.append(N//modulus[i])         # Thêm vào mảng các giá trị nguyên của (N//n_i)   
    Mi = []
    for i in range(len(modulus)):        # Lấy ra các chỉ số phần tử trong mảng modulus
        Mi.append(pow(Ni[i], -1, modulus[i])) # Thêm vào mảng giá trị của nghịch đảo modulus N_i
    SIGMA = 0
    for i in range(len(modulus)):
        SIGMA += remainder[i]*Ni[i]*Mi[i]
    return SIGMA%N
n0 = 14528915758150659907677315938876872514853653132820394367681510019000469589767908107293777996420037715293478868775354645306536953789897501630398061779084810058931494642860729799059325051840331449914529594113593835549493208246333437945551639983056810855435396444978249093419290651847764073607607794045076386643023306458718171574989185213684263628336385268818202054811378810216623440644076846464902798568705083282619513191855087399010760232112434412274701034094429954231366422968991322244343038458681255035356984900384509158858007713047428143658924970374944616430311056440919114824023838380098825914755712289724493770021
e = 3
c0 = 6965891612987861726975066977377253961837139691220763821370036576350605576485706330714192837336331493653283305241193883593410988132245791554283874785871849223291134571366093850082919285063130119121338290718389659761443563666214229749009468327825320914097376664888912663806925746474243439550004354390822079954583102082178617110721589392875875474288168921403550415531707419931040583019529612270482482718035497554779733578411057633524971870399893851589345476307695799567919550426417015815455141863703835142223300228230547255523815097431420381177861163863791690147876158039619438793849367921927840731088518955045807722225


n1 = 20463913454649855046677206889944639231694511458416906994298079596685813354570085475890888433776403011296145408951323816323011550738170573801417972453504044678801608709931200059967157605416809387753258251914788761202456830940944486915292626560515250805017229876565916349963923702612584484875113691057716315466239062005206014542088484387389725058070917118549621598629964819596412564094627030747720659155558690124005400257685883230881015636066183743516494701900125788836869358634031031172536767950943858472257519195392986989232477630794600444813136409000056443035171453870906346401936687214432176829528484662373633624123
e = 3
c1 = 5109363605089618816120178319361171115590171352048506021650539639521356666986308721062843132905170261025772850941702085683855336653472949146012700116070022531926476625467538166881085235022484711752960666438445574269179358850309578627747024264968893862296953506803423930414569834210215223172069261612934281834174103316403670168299182121939323001232617718327977313659290755318972603958579000300780685344728301503641583806648227416781898538367971983562236770576174308965929275267929379934367736694110684569576575266348020800723535121638175505282145714117112442582416208209171027273743686645470434557028336357172288865172


n2 = 19402640770593345339726386104915705450969517850985511418263141255686982818547710008822417349818201858549321868878490314025136645036980129976820137486252202687238348587398336652955435182090722844668488842986318211649569593089444781595159045372322540131250208258093613844753021272389255069398553523848975530563989367082896404719544411946864594527708058887475595056033713361893808330341623804367785721774271084389159493974946320359512776328984487126583015777989991635428744050868653379191842998345721260216953918203248167079072442948732000084754225272238189439501737066178901505257566388862947536332343196537495085729147
e = 3
c2 = 5603386396458228314230975500760833991383866638504216400766044200173576179323437058101562931430558738148852367292802918725271632845889728711316688681080762762324367273332764959495900563756768440309595248691744845766607436966468714038018108912467618638117493367675937079141350328486149333053000366933205635396038539236203203489974033629281145427277222568989469994178084357460160310598260365030056631222346691527861696116334946201074529417984624304973747653407317290664224507485684421999527164122395674469650155851869651072847303136621932989550786722041915603539800197077294166881952724017065404825258494318993054344153


n3 = 12005639978012754274325188681720834222130605634919280945697102906256738419912110187245315232437501890545637047506165123606573171374281507075652554737014979927883759915891863646221205835211640845714836927373844277878562666545230876640830141637371729405545509920889968046268135809999117856968692236742804637929866632908329522087977077849045608566911654234541526643235586433065170392920102840518192803854740398478305598092197183671292154743153130012885747243219372709669879863098708318993844005566984491622761795349455404952285937152423145150066181043576492305166964448141091092142224906843816547235826717179687198833961
e = 3
c3 = 1522280741383024774933280198410525846833410931417064479278161088248621390305797210285777845359812715909342595804742710152832168365433905718629465545306028275498667935929180318276445229415104842407145880223983428713335709038026249381363564625791656631137936935477777236936508600353416079028339774876425198789629900265348122040413865209592074731028757972968635601695468594123523892918747882221891834598896483393711851510479989203644477972694520237262271530260496342247355761992646827057846109181410462131875377404309983072358313960427035348425800940661373272947647516867525052504539561289941374722179778872627956360577


n4 = 17795451956221451086587651307408104001363221003775928432650752466563818944480119932209305765249625841644339021308118433529490162294175590972336954199870002456682453215153111182451526643055812311071588382409549045943806869173323058059908678022558101041630272658592291327387549001621625757585079662873501990182250368909302040015518454068699267914137675644695523752851229148887052774845777699287718342916530122031495267122700912518207571821367123013164125109174399486158717604851125244356586369921144640969262427220828940652994276084225196272504355264547588369516271460361233556643313911651916709471353368924621122725823
e = 3
c4 = 8752507806125480063647081749506966428026005464325535765874589376572431101816084498482064083887400646438977437273700004934257274516197148448425455243811009944321764771392044345410680448204581679548854193081394891841223548418812679441816502910830861271884276608891963388657558218620911858230760629700918375750796354647493524576614017731938584618983084762612414591830024113057983483156974095503392359946722756364412399187910604029583464521617256125933111786441852765229820406911991809039519015434793656710199153380699319611499255869045311421603167606551250174746275803467549814529124250122560661739949229005127507540805


n5 = 25252721057733555082592677470459355315816761410478159901637469821096129654501579313856822193168570733800370301193041607236223065376987811309968760580864569059669890823406084313841678888031103461972888346942160731039637326224716901940943571445217827960353637825523862324133203094843228068077462983941899571736153227764822122334838436875488289162659100652956252427378476004164698656662333892963348126931771536472674447932268282205545229907715893139346941832367885319597198474180888087658441880346681594927881517150425610145518942545293750127300041942766820911120196262215703079164895767115681864075574707999253396530263
e = 3
c5 = 23399624135645767243362438536844425089018405258626828336566973656156553220156563508607371562416462491581383453279478716239823054532476006642583363934314982675152824147243749715830794488268846671670287617324522740126594148159945137948643597981681529145611463534109482209520448640622103718682323158039797577387254265854218727476928164074249568031493984825273382959147078839665114417896463735635546290504843957780546550577300001452747760982468547756427137284830133305010038339400230477403836856663883956463830571934657200851598986174177386323915542033293658596818231793744261192870485152396793393026198817787033127061749


n6 = 19833203629283018227011925157509157967003736370320129764863076831617271290326613531892600790037451229326924414757856123643351635022817441101879725227161178559229328259469472961665857650693413215087493448372860837806619850188734619829580286541292997729705909899738951228555834773273676515143550091710004139734080727392121405772911510746025807070635102249154615454505080376920778703360178295901552323611120184737429513669167641846902598281621408629883487079110172218735807477275590367110861255756289520114719860000347219161944020067099398239199863252349401303744451903546571864062825485984573414652422054433066179558897
e = 3
c6 = 15239683995712538665992887055453717247160229941400011601942125542239446512492703769284448009141905335544729440961349343533346436084176947090230267995060908954209742736573986319254695570265339469489948102562072983996668361864286444602534666284339466797477805372109723178841788198177337648499899079471221924276590042183382182326518312979109378616306364363630519677884849945606288881683625944365927809405420540525867173639222696027472336981838588256771671910217553150588878434061862840893045763456457939944572192848992333115479951110622066173007227047527992906364658618631373790704267650950755276227747600169403361509144
n=[n0,n1,n2,n3,n4,n5,n6]
c=[c0,c1,c2,c3,c4,c5,c6]
for i, j, k in combinations(range(len(n)),3): # Tạo ra một tổ hợp chập 3 phần tử không lặp lại nhau của mảng
    modulus = [n[i], n[j], n[k]]        # Thiết lập mảng modulus
    remainder = [c[i], c[j], c[k]]      # Thiết lập mảng số dư
    m = iroot(CRT(remainder, modulus), 3)
    FLAG = long_to_bytes(m[0])
    # if b'crypto{' in FLAG:            
    print(FLAG)
```        
Ans: crypto{1f_y0u_d0nt_p4d_y0u_4r3_Vuln3rabl3}

# Primes part 2
## 18. Infinite Descent
```python
from Crypto.Util.number import long_to_bytes, inverse
n = 383347712330877040452238619329524841763392526146840572232926924642094891453979246383798913394114305368360426867021623649667024217266529000859703542590316063318592391925062014229671423777796679798747131250552455356061834719512365575593221216339005132464338847195248627639623487124025890693416305788160905762011825079336880567461033322240015771102929696350161937950387427696385850443727777996483584464610046380722736790790188061964311222153985614287276995741553706506834906746892708903948496564047090014307484054609862129530262108669567834726352078060081889712109412073731026030466300060341737504223822014714056413752165841749368159510588178604096191956750941078391415634472219765129561622344109769892244712668402761549412177892054051266761597330660545704317210567759828757156904778495608968785747998059857467440128156068391746919684258227682866083662345263659558066864109212457286114506228470930775092735385388316268663664139056183180238043386636254075940621543717531670995823417070666005930452836389812129462051771646048498397195157405386923446893886593048680984896989809135802276892911038588008701926729269812453226891776546037663583893625479252643042517196958990266376741676514631089466493864064316127648074609662749196545969926051
e = 65537
c = 98280456757136766244944891987028935843441533415613592591358482906016439563076150526116369842213103333480506705993633901994107281890187248495507270868621384652207697607019899166492132408348789252555196428608661320671877412710489782358282011364127799563335562917707783563681920786994453004763755404510541574502176243896756839917991848428091594919111448023948527766368304503100650379914153058191140072528095898576018893829830104362124927140555107994114143042266758709328068902664037870075742542194318059191313468675939426810988239079424823495317464035252325521917592045198152643533223015952702649249494753395100973534541766285551891859649320371178562200252228779395393974169736998523394598517174182142007480526603025578004665936854657294541338697513521007818552254811797566860763442604365744596444735991732790926343720102293453429936734206246109968817158815749927063561835274636195149702317415680401987150336994583752062565237605953153790371155918439941193401473271753038180560129784192800351649724465553733201451581525173536731674524145027931923204961274369826379325051601238308635192540223484055096203293400419816024111797903442864181965959247745006822690967920957905188441550106930799896292835287867403979631824085790047851383294389
p = 19579267410474709598749314750954211170621862561006233612440352022286786882372619130071639824109783540564512429081674132336811972404563957025465034025781206466631730784516337210291334356396471732168742739790464109881039219452504456611589154349427303832789968502204300316585544080003423669120186095188478480761108168299370326928127888786819392372477069515318179751702985809024210164243409544692708684215042226932081052831028570060308963093217622183111643335692361019897449265402290540025790581589980867847884281862216603571536255382298035337865885153328169634178323279004749915197270120323340416965014136429743252761521
q = 19579267410474709598749314750954211170621862561006233612440352022286786882372619130071639824109783540564512429081674132336811972404563957025465034025781206466631730784516337210291334356396471732168742739790464109881039219452504456611589154349427303832789968502204300316585544080003423669120186095188478480761108168299370326928127888786819392372477069515318179751702985809024210164243409544692708684215042226932081052831028570060308963093217622183111643335692362635203582868526178838018946986792656819885261069890315500550802303622551029821058459163702751893798676443415681144429096989664473705850619792495553724950931
phi = (p - 1)*(q - 1)
d = inverse (e, phi)
m = long_to_bytes(pow(c, d, n))
print (m)
```
Ans: crypto{f3rm47_w45_4_g3n1u5}

## 19. Marin's Secrets
Ở bước đầu tiên, khi sử dụng factordb thì N được phân tích ra dạng 2 số nguyên tố có dạng 2^{p} - 1

Trong lý thuyết số có một dạng số nguyên tố biểu diễn dưới dạng 2{p} - 1 là số Mersenne với p là một số nguyên p dẫn đển số Mersenne phải là một số nguyên tố, tuy nhiên không phải số nguyên tố p nào cũng dẫn tới số Mersenne

Cho tới ngày nay con người mới chỉ có khả năng phân tích được tới 52 số vậy nên với các số Mersenne hiện tại là một dãy hữu hạn

Sử dụng thuật toán trên tìm p, q và bẻ khoá bài toán như bình thường
```python
from Crypto.Util.number import inverse, long_to_bytes
n = 658416274830184544125027519921443515789888264156074733099244040126213682497714032798116399288176502462829255784525977722903018714434309698108208388664768262754316426220651576623731617882923164117579624827261244506084274371250277849351631679441171018418018498039996472549893150577189302871520311715179730714312181456245097848491669795997289830612988058523968384808822828370900198489249243399165125219244753790779764466236965135793576516193213175061401667388622228362042717054014679032953441034021506856017081062617572351195418505899388715709795992029559042119783423597324707100694064675909238717573058764118893225111602703838080618565401139902143069901117174204252871948846864436771808616432457102844534843857198735242005309073939051433790946726672234643259349535186268571629077937597838801337973092285608744209951533199868228040004432132597073390363357892379997655878857696334892216345070227646749851381208554044940444182864026513709449823489593439017366358869648168238735087593808344484365136284219725233811605331815007424582890821887260682886632543613109252862114326372077785369292570900594814481097443781269562647303671428895764224084402259605109600363098950091998891375812839523613295667253813978434879172781217285652895469194181218343078754501694746598738215243769747956572555989594598180639098344891175879455994652382137038240166358066403475457 
e = 65537
c = 400280463088930432319280359115194977582517363610532464295210669530407870753439127455401384569705425621445943992963380983084917385428631223046908837804126399345875252917090184158440305503817193246288672986488987883177380307377025079266030262650932575205141853413302558460364242355531272967481409414783634558791175827816540767545944534238189079030192843288596934979693517964655661507346729751987928147021620165009965051933278913952899114253301044747587310830419190623282578931589587504555005361571572561916866063458812965314474160499067525067495140150092119620928363007467390920130717521169105167963364154636472055084012592138570354390246779276003156184676298710746583104700516466091034510765027167956117869051938116457370384737440965109619578227422049806566060571831017610877072484262724789571076529586427405780121096546942812322324807145137017942266863534989082115189065560011841150908380937354301243153206428896320576609904361937035263985348984794208198892615898907005955403529470847124269512316191753950203794578656029324506688293446571598506042198219080325747328636232040936761788558421528960279832802127562115852304946867628316502959562274485483867481731149338209009753229463924855930103271197831370982488703456463385914801246828662212622006947380115549529820197355738525329885232170215757585685484402344437894981555179129287164971002033759724456
prime_arr = [2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 2203, 2281, 3217, 4253, 4423, 9689, 9941, 11213, 19937, 21701, 23209, 44497, 86243, 110503, 132049, 216091, 756839, 859433, 1257787, 1398269, 2976221, 3021377, 6972593, 13466917, 20996011, 24036583, 25964951, 30402457, 32582657, 37156667, 42643801, 43112609, 57885161, 74207281, 77232917] # Liệt kê các số nguyên tố p theo danh sách trên Wikipedia
for prime in prime_arr:
    p = pow(2, prime) - 1
    if n%p == 0:
        q = n//p
        print(p)    #p: prime = 2203
        print(q)    #q: prime = 2281
        break
phi = (p - 1)*(q - 1)     
d = inverse (e, phi)
m = pow(c, d, n)
FLAG = long_to_bytes(m).decode() # đổi sang kiểu dữ liệu String
print(FLAG)
```
Ans: crypto{Th3se_Pr1m3s_4r3_t00_r4r3}

## 20. Fast Primes

```python
from Crypto.Cipher import PKCS1_OAEP
from Crypto.PublicKey import RSA
from Crypto.Util.number import long_to_bytes, inverse
from Crypto.Util import number
# Sử dụng RSA.importKey sẽ giúp tạo ra Key với dữ liệu bên trong là một string

key = RSA.importKey(open("/home/william/Downloads/key_17a08b7040db46308f8b9a19894f9f95.pem", "rb").read()) # Mở file key.pem ở dạng nhị phân, đọc và chuyển sang string  
print("n = ", key.n)
print("e = ", key.e)

n = 4013610727845242593703438523892210066915884608065890652809524328518978287424865087812690502446831525755541263621651398962044653615723751218715649008058509
e = 65537
p = 51894141255108267693828471848483688186015845988173648228318286999011443419469
q = 77342270837753916396402614215980760127245056504361515489809293852222206596161
phi = (p - 1)*(q - 1)
d = pow(e,-1,phi)
key = RSA.construct((n, e, d))
cipher = PKCS1_OAEP.new(key)
hex = 0x249d72cd1d287b1a15a3881f2bff5788bc4bf62c789f2df44d88aae805b54c9a94b8944c0ba798f70062b66160fee312b98879f1dd5d17b33095feb3c5830d28
c = long_to_bytes(hex)
m = cipher.decrypt(c)
print(m)
```
Ans: crypto{p00R_3570n14}










     


